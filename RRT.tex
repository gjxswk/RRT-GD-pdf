%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%2345678901234567890123456789012345678901234567890123456789012345678901234567890
%        1         2         3         4         5         6         7         8

\documentclass[letterpaper, 10 pt, conference]{ieeeconf}  % Comment this line out if you need a4paper

%\documentclass[a4paper, 10pt, conference]{ieeeconf}      % Use this line for a4 paper

\IEEEoverridecommandlockouts                              % This command is only needed if 
                                                          % you want to use the \thanks command

\overrideIEEEmargins                                      % Needed to meet printer requirements.

% See the \addtolength command later in the file to balance the column lengths
% on the last page of the document

% The following packages can be found on http:\\www.ctan.org
%\usepackage{graphics} % for pdf, bitmapped graphics files
%\usepackage{epsfig} % for postscript graphics files
%\usepackage{mathptmx} % assumes new font selection scheme installed
%\usepackage{times} % assumes new font selection scheme installed
%\usepackage{amsmath} % assumes amsmath package installed
%\usepackage{amssymb}  % assumes amsmath package installed

\usepackage{graphics}
\usepackage{amsmath} 
\usepackage{amssymb}
\usepackage{multirow}

\def\degree{${}^{\circ}$}
	  
\title{\LARGE \bf
Robot Path Planning Using Newton-Raphson method Based on RRT-GD
}


\author{Junxiang Ge, Chunfang Liu, Fuchun Sun$^{1}$% <-this % stops a space
%\thanks{*This work was not supported by any organization}% <-this % stops a space
\thanks{$^{1}$State Key Lab of Intelligent Technology and Systems, Tsinghua National Laboratory for Information Science and Technology (TNList), Department of Computer Science and Technology, Tsinghua University.
        {\tt\small gejx14@mails.tsinghua.edu.cn, fcsun@tsinghua.edu.cn}}%
}

\begin{document}



\maketitle
\thispagestyle{empty}
\pagestyle{empty}


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\begin{abstract}

We proposed a method on 7-arm redundant manipulator for obstacle-avoiding path planning. As we all know, RRT (rapidly-exploring random tree) method can perform well when doing obstacle-avoiding works. But the traditional RRT method concentrates mainly on the status space(S-space), it can’t predict the end actuator’s trajectory, thus ending up with the separation between end actuator and robot joints. In this paper, we use RRT method in the configuration space(C-space), concentrating on both the end actuator’s status and the joints’ movements. In order to reduce the time for path planning, i.e., reduce the steps when doing RRT, we change RRT algorithm to be goal-direction (we call it RRT-GD), adapt to our common works. With this improve, we can see in this paper that result could be reached in less than 10 steps usually, while the original RRT algorithm needs often more than 100 steps doing the same task. In addition, we apply Newton-Raphson method to RRT to do inverse kinematics optimization, thus we can focus on both the S-space and C-Space. In the end, we use quintic polynomial to smooth the planning path.

\end{abstract}


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{Introduction}

As we all know, RRT (Rapidly-exploring random tree) is rapidly used in obstacle-avoiding path planning for redundant manipulator. It constructs a graph of obstacle free points in feasible space based on random sampling, in which we search the feasible path from the initial point to goal point. As a result of this, there are some great properties with RRT method compared to other obstacle-avoiding method:
\begin{itemize}
\item RRT method attends to explore unknown space. 
\item The graph constructed by RRT will gradually fill up the feasible space if the exploring times is enough.
\item RRT method don’t need precise modeling, instead, it only needs the information that if a point is obstacle free through collision detect. Thus ending up with the high efficiency of obstacle free planning.
\end{itemize}

Though it has these advantages, RRT will still perform low planning success rate when there is a great deal of obstacle surround, or the free degree of manipulator is high. In this way, Kuffner proposed a bidirectional RRT algorithm, bi-RRT, also called RRT-connect. Within this method, two trees were built based on the initial point and goal point separately. When expanding each time, the tree of initial point will extend to the other tree, or the contrary way, until the two trees meets. For it has goal heuristic, it improves the success rate of path planning.  

In spite of these advantages of RRT and its modified algorithm, we still find it defective sometimes in doing our common works. As mentioned before, RRT attends to explore unknown space, so that it could exploring the whole free space. But we just don’t need to explore the whole space when doing simply goal-reaching works. In this way, all we need to do is to find a feasible way from initial point to goal point without obstacle collision, i.e., we only need to explore a part of the whole space include initial point, goal point, and some obstacle. Thus we proposed RRT-GD (RRT with goal-directionality), using the train of thought above. As we can see later in this paper, by doing this way, we can get the result rapidly, usually ten times faster than the normal RRT method.

As we doing RRT in C-space (configuration space), we need to compute the joint angles of each point in the path tree, i.e. inverse kinematics optimization. There are also a lot of methods to do inverse kinematics optimization, e.g., GP (gradient projection method), WLN (weighted least norm	 method), extended Jacobi method, etc. In this paper, we adopt Newton-Raphson method to do this inverse kinematics optimization work. Compared to other methods, Newton-Raphson method performs faster and more accurate. Provided the result can get by Newton-Raphson method, it would take only less than 10 iteration times (usually 5 or 6 times), with bias less than micro-meters. 

After we get the path from initial point to goal point, with detailed status information (pose \& joint angles), we then use quintic polynomial to smooth the path [9]. We show our results in the experiment result part of this paper, and then make comparison with the other methods mentioned above.  

We organize this paper according to our experiment process, to show our results more fluently. First, we discuss the basic mathematics knowledge and algorithm we use, include RRT and its modified method in more detail. Then, we introduce Newton-Raphson method in inverse kinematics by using the normal RRT method. After that, we present quintic polynomial method in smoothing path. Later, in order to accelerate the planning time and doing works real-time, we propose RRT-GD method, which press more close to our work in common use.

\section{Experiment Environment}

All the results we show is based on a redundant robot arm. Before introduce our algorithm, we can have a look at the basic environment.

\subsection{Robot Model \& Its Relevant Variables (Heading 2)}

We use a 7-arm redundant robot manipulator to test the results in our experiment. We use the DH method (Denavit and Har- tenberg method) to model our robot arm, with the model axis built obeying D-H parameter method as the Fig.1 show.

   \begin{figure}[thpb]
      \centering
      \framebox{\parbox{2.2in}
      {\includegraphics{robotaxis.eps}
}}
      \caption{Robot axis coordinates, obeying D-H parameter method, numbers in the graph is in milimeter.}
      \label{figurelabel}
   \end{figure}
   
As a result of this axis coordinates, we get the DH parameters as follow (show in table 1) :

\begin{table}[h]
\caption{$DH\ Parameters\ of\ robot.\ (\theta: joint\ angle;\ d: connecting\ rod\ skew;\ a: connecting\ rod;\ \alpha: tortuosity\ angle\ of\ connecting\ rod.)$}
\label{table1}
\begin{center}
\begin{tabular}{c|ccccc}
\hline
Joint Number & $\theta_i$ & $d_i$(mm) & $a_i$(mm) & ${\alpha_i}$(\degree) & area of $\theta_i$(\degree) \\
\hline
1 & $q_1$ & 300 & 0 & -90 & -180$\sim$180\\
2 & $q_2$ & 0 & 0 & 90 & -90$\sim$90 \\
3 & $q_3$ & 328 & 0 & -90 & -180$\sim$180\\
4 & $q_4$ & 0 & 0 & 90 & -120$\sim$120\\
5 & $q_5$ & 277 & 0 & -90 & -180$\sim$180\\
6 & $q_6$ & 0 & 0 & 90 & -120$\sim$120\\
7 & $q_7$ & 310 & 0 & 0 & -180$\sim$180\\
\hline
\end{tabular}
\end{center}
\end{table}

All our later works are based on table 1 and fig.1,  including experiments and simulation. As we can see in fig.1, the joint angles from $q_1$ to $q_7$ are the free variables and the others are fixed within our experiments. So when we write rotation and translation matrix in homogeneous way, which is a 4$\times$4 matrix, we can get the transformation equation from current coordinate ($x_i$, $y_i$, $z_i$) to the next coordinate ($x_{i+1}$, $y_{i+1}$, $z_{i+1}$) as below:

$$
\begin{array}{cc}
^{i-1}T_{i} = A_{i} = &Rot(z, \theta_{i})\cdot \ Trans(0, 0, d_{i}) \ \cdot \\\ &Trans(a_{i}, 0, 0) \ \cdot \ Rot(x, \alpha_{i}). \\\ 
\end{array}
  \eqno({1})
$$ 

Among (1), Rot(z, $\theta$) means homogeneous transformation matrix when rotate the current coordinate $\theta$ degree around z-axis, and Trans(x, y, z) means homogeneous transformation matrix when transform the current cordiante with the vector $\vec{v} = (x, y, z)$. 

Then, we can get the transformation matrix from base coordinate ($x_0$, $y_0$, $z_0$) to the end manipulator coordinate ($x_7$, $y_7$, $z_7$) as follow:

$$
M \ = \ ^{0}T_{1} \ ^{1}T_{2} \ldots ^{6}T_{7} \eqno({2})
$$
\subsection{Status Space \& Configuration Space}

Status Space is expressed with 7 parameters from $q_1$ to $q_7$, with the expression like this:

$$
S \ = \ (q_{1}, q_{2}, \ ...  \ , q_{7}) \eqno({3})
$$

As for the configuration space, i.e., pose space, we use Euler angles that obeys Euler Z-X-Z transformation rules to express the azimuth angles, which displays like $\gamma = (\psi, \theta, \phi)$. Position writes like $P=(x,y,z)$. Get the position and Euler angles together, we define the expression of pose like this:

$$
X = (P,\gamma) = (x,y,z,\psi,\theta,\phi) \eqno({4})
$$

See that S is expressed with 7 free variables while X with 6,  which tells the redundancy of our system, on which our work is based. 

\subsection{Forward Kinematics \& Jacobian Matrix}

As we can see in (2) \& (3),  M is decided by the current state S,  thus the current pose X is also decided. When we transform X into homogeneous matrix defined as $H(X)$ and write M as $M(S)$ (means M is decided by S), we get the connection between S and X:

$$
H(X) = M(S) \eqno({5})
$$

That is what our forward kinematics based on. Knowing the current S, we can get $M(S)$ from (2), then use (5) to get X. The detail operation from H(X) to X will not be discussed here, which can be easily found in primary textbook of robot kinematics. Combineg the process of  turning $H(X)$ to X in M, we can finally get forward kinematics as below:

$$
X = M(S) \eqno({6})
$$ 

The letter M in (6) is not the same meaning with (2) \& (5), which combining the process from $H(X)$ to X. We can see M here in (6) as just a function with independent variables S and dependent variables X.

\subsection{Inverse Kinematics \& the Extend Inverse Jocobian Matrix}

Inverse kinematics comes with the question: How could we get S when we know X? Since the system is reduntant, there may not be only one answer for S.  There are methods from X to S directly using fixed angle, but we do inverse kinematics with the help of Jacobian matrix instead. 

Looking back at (6), we write M in partial form: 

$$
X = 
\left[
\begin{array}{c}
X_{1} \\
X_{2} \\
X_{3} \\
X_{4} \\
X_{5} \\
X_{6} \\
\end{array}
\right]
=
\left[
\begin{array}{c}
M_{1}(q_{1}, q_{2}, \ldots , q_{7}) \\
M_{2}(q_{1}, q_{2}, \ldots , q_{7}) \\
M_{3}(q_{1}, q_{2}, \ldots , q_{7}) \\
M_{4}(q_{1}, q_{2}, \ldots , q_{7}) \\
M_{5}(q_{1}, q_{2}, \ldots , q_{7}) \\
M_{6}(q_{1}, q_{2}, \ldots , q_{7}) \\
\end{array}
\right]
\eqno({7})
$$

The Jacobian Matrix is defined as (8):

$$
\begin{array}{ll}
J & = (\frac{\partial M}{\partial q_{1}},\frac{\partial M}{\partial q_{2}}, \ \ldots  \ , \frac{\partial M}{\partial q_{7}})   \\
\\
& = 
\left[
\begin{array}{cccc}
\frac{\partial M_{1}}{\partial q_{1}}, & \frac{\partial M_{1}}{\partial q_{2}}, & \ldots & \frac{\partial M_{1}}{\partial q_{7}} \\
\frac{\partial M_{2}}{\partial q_{1}}, & \frac{\partial M_{2}}{\partial q_{2}}, & \ldots & \frac{\partial M_{2}}{\partial q_{7}} \\
\vdots & \vdots & \ddots & \vdots \\
\frac{\partial M_{6}}{\partial q_{1}}, & \frac{\partial M_{6}}{\partial q_{2}}, & \ldots & \frac{\partial M_{6}}{\partial q_{7}} \\
\end{array}
\right]
\\
\end{array}
\eqno({8}) 
$$

In our expremental environment, the Jacobian matrix should be a 6$\times$7 matrix for 6 pose variables and 7 joint angle variables, but which is not the same with all redundant manipulator. Then we get the relation between X and S in differential way:

$$
\dot{X} = J\dot{S} = J(\dot{q_{1}}, \dot{q_{2}}, \ldots, \dot{q_{7}}) \eqno({9})
$$

We can't use the direct inverse matrix of J to do inverse kinematics, but can do it with the generalized inverse matrix of J ($J^{+}$) defined like this:

$$
J^{+} = J^{T}(JJ^{T})^{-1} \eqno({10})
$$

In generalized form, we have:

$$
\dot{S} = J^{+}\dot{X} \eqno({11})
$$
$$
S - S_{0} = \Delta S = J^{+}\Delta X = J^{+} (X - X_{0}) \eqno({12})
$$

In this way, when knowing the initial pose $X_{0}$, very near pose X, and the initial $S_{0}$, we can compute the status S relative to X according to (11)(12), which is our inverse kinematics based on, both for MLG and Newton-Raphson method we will introduce later.

\section{RRT with extended steps}

Since we use modified RRT to do obstacle-avoiding path planning, we can have a look at the initial RRT method to better understand the results. In this chapter, we introduce RRT and relevant algorithm in a more detail way.

\subsection{Pre-define before RRT}

We define the relevant collection and functions below of RRT before looking at its sudocode. Remind the basic problem RRT do with first:  how can we run the manipulator from the initial position (knowing $X_{0}$ \& $S_{0}$) to the goal position (only knowing pose of end position, taken down as $X_{g}$) without collision into the obstacle in the space? The following collection are defined to express RRT in convenience:

\begin{itemize}

\item $A_{0}$: whole pose space which can be reached by robot manipulator in configuration space.

\item $A_{free}$: free space belong to $A_{0}$, i.e., $A_{free} \in A_{0}$, and there is no obstacle in $A_{free}$. 

\item $A_{obs}$: space of obstacle, i.e., $A_{obs} = A_{0}  \backslash A_{free}$.

\item $B_{0}, B_{free}, B{obs}$: these are the corresponding collection with A, but in the status space. The subscript takes the same meaning as in A.

\end{itemize}

Below define the main functions used in RRT. Before we focus on these functions, we should remind that RRT method will build a tree when it runs, we called it RRT tree, writen as tree $T$, with the initial point $X_{0}$ for pose and  $S_{0}$ for status as the first tree point. We note that: $T = (V, E)$, while V is for all points and E is the relation between these points (father point and its child). Note that T is a tree, so each point has no more than one child.

\begin{itemize}

\item sample:  generate a random point $X_{ram}$ in pose format in $A_{free}$.

\item distance:  compute the distance of two points in $A_{0}$. Within our work, this distance is defined as the Euclid distance.

\item nearest\_neighbor: given the point X, this function return the nearest point $X_{near}$ in tree $T$.

\item steer: given the random point $X_{ram}$ and $X_{near}$, this function return a new point $X_{new}$ in $A_{free}$, whihc is nearer to $X_{ram}$ than $X_{near}$.

\item collisionTest: given point $X$, return 1 for obstacle free and 0 for obstacle collision. 

\end{itemize}

\subsection{RRT and its relative functions}

Then we can have a look at the basic algorithm of RRT. We write it in pseudocode show in Fig.2:

\begin{figure}[thpb]
      \centering
      \framebox{
      \parbox{3in}
      {
      $
      RRT (S_{0}, A_{0})\\
      1.\ V \leftarrow \{S_{0}\}; E \leftarrow \o; i \leftarrow 0;\\
      2.\ while\ i < N\ do \\
      3.\ \{ \\
      4.\qquad T \leftarrow (V,\ E); \\
      5.\qquad X_{rand} \leftarrow sample(i); i \leftarrow i+1; \\
      6.\qquad T \leftarrow extend(T, X_{rand});\\
      7.\ \} \\
      $
      \\
      $
      extend(T, X_{rand}) \\
      1.\ X_{near}=  nearest\_neighbor(T, X_{rand});\\
      2.\ X_{new} = steer(X_{near}, X_{rand});\\
      3.\ if\ X_{new}\ and\ collisionTest(X_{new})\\\
      4.\qquad V \leftarrow V \cup \{X_{new}\};\\
      5.\qquad E \leftarrow E \cup \{(X_{near}, X_{new})\};\\
      5.\qquad return\ success;\\
      6.\ else\\
      7.\qquad return\ fail;
      $
	 }
}
      \caption{pseudocode of RRT algorithm.}
      \label{figurelabe2}
\end{figure}
 
 Though simple as it is, RRT work well with obstacle-avoiding task. Here, we focus on the detail of the basic functions specially, for they will be related later in this paper. As defined before, we use Euclid distance but make a little change, named rrtDistance, that is defined bellow with (13):
 

 $$
 \begin{array}{ll}
 &rrtDistance(X_{1},X_{2})=\alpha ||P_{1}-P_{2}|| + \\
& \qquad\qquad (1-\alpha) ||\gamma_{1}-\gamma_{2}||, \ 0 < \alpha < 1. 
\end{array}
\eqno(13)
 $$

   
 Since we concentrate more on the accuracy of position, we mainly choose $\alpha > 0.5$, like $\alpha = 0.8$, which is use in our program.  The sample function generate a point in $A_{0}$, we use $X_{min}$ and $X_{max}$ to limit area of $A_{0}$. Then the random point $X_{ram}$ that sample function produce will be like (14):
 
 $$
 X_{ram} = X_{min} + t \times (X_{max}-X_{min}), 0<t<1;
 \eqno({14})
 $$
 
When t is randomly produce in interval (0, 1), sample method would produce all the points of $A_{0}$. For steer function, a new point $X_{new}$ will be produce depending on $X_{near}$ and $X_{ram}$,  which works like (15):
 
 $$
 \begin{array}{rr}
 X_{new} = X_{near} + s(X_{ram}-X_{near})/||X_{ram}-&\\
 X_{near}||,\ 0<s<||X_{ram}-X_{near}||.&
 \end{array}
 \eqno(15)
 $$
 
 We call $s$ in (15) the step-length. In RRT algorithm, each step when steer function run, the RRT tree $T$ will attend to explore forward $s$ distance in $A_{0}$. Cause $X_{rand}$ will be anywhere in the whole space, it is easy to infer that the direction tree $T$ extends is all-dimension, i.e., no certain direction, but different direction with different time, reminded that is important cause we will discuss it later.
 
\subsection{modified RRT algorithm}

Though RRT can explore the whole space $A_{0}$ to get a obstacle free path to reach the goal point, it still has some shortage when it actually run. Since RRT extends only one step (with step-length $s$) further, it seems slow sometimes when $A_{0}$ is big enough. On the other point, RRT tree are built beginning with the initial point, leaving out the goal point in the tree-built process. Still, there are also other insufficients with RRT, which results in many modified RRT method. Here, we present bi-RRT as an example. The detail bi-RRT algorithm can be seen in [12]. We just take it in brief here.

As the shortage we tell, bi-RRT solve it by extend more steps until in collision with obstacle or reach the random point $X_{ram}$.  And bi-RRT maintain two tree in its memory, one starting extend function from the initial point and the other from the goal point. The two tree extend to each other each tiem when extend method run until they meet in the space, which is the reason the name `bi-RRT' come from. With such modification, bi-RRT take in count of the intial point and goal point together with a faster extending speed. 

In our exprement, we just take the more steps extending thought into our code. Our multi-extend algorithm is like in Fig.3:

\begin{figure}[thpb]
      \centering
      \framebox{
      \parbox{3in}
      {
      $
      multi\_extend(T, X_{rand})\\
      1.\ [X_{new}, result] = extend(T, X_{rand});\\
      2.\ if\ result = fail\ or\ collisionTest(X_{new}) = 0\\
      3.\qquad return\ fail;\\
      4.\ while\ result = success \\
      5.\ \{ \\
      6.\qquad [X_{new}, result] = extend(X_{new}, X_{rand});\\
      \begin{aligned}
      7.\qquad if\ collision&Test(X_{new}) = 0\ or\ \\ &surpass(X_{new}, X_{rand})\\
      \end{aligned} \\
      8.\qquad \qquad break; \\
      9.\ \} \\
      10.\ return\ success.
      $
	 }
}
      \caption{multi-step extend pseudocode}
      \label{figurelabe3}
\end{figure}

The function `$surpass(X_{new},X_{rand})$' detect that if $X_{new}$ is near enough to $X_{rand}$. The `true' return for this function means the two points are close enough, then `multi\_extend' method will be stop, and the `false' return will continue the extending process.  With these change, if the extend direction is correct, we could get faster to the goal point, but simutaneously, we would also extend further to a bad direction, which would take up more time if this situation happens frequently. We solve this problem with RRT-GD (RRT with goal-direction), which will be related in the later paragraph. But within our process now, we have two extend functions: extend and multi-extend, and we can think of the inverse kinematics optimization, which will be discuss first.

\section{Inverse Kinematics with Newton-Raphson method}

We have related some inverse kinematics method before, e.g., GP (gradient projection method), WLN (weighted least norm method), MLG (method of most likely gradient)[6]. Within our program, we take Newton-Raphson method into account, for its high accuracy and speed. 

\subsection{Newton-Raphson method}

We reminded back to our inverse kinematics problem: we know $S_{0}$ (and so $X_{0}$ can be compute) and $X_{g}$, how could we compute $S_{g}$? In Newton-Raphson method, which is an iteration method, each time we just go straight from the current point to goal point. We can see the iteration equation in (16):

$$
S_{n+1} = S_{n} + J^{+} \times minus(X_{g}, X_{n}).
\eqno(16)
$$ 

The current status and pose are written as $S_{n}$ and $X_{n}$, and $J^{+}$ is also relative to the current point, which can be compute in (10). Then when $X_{n}$ is close enough to $X_{g}$, we get the answer $S_{n}$ as result $S_{g}$. Note that though the function name called `minus', it dost just not simple minus as $X_{g} - X_{n}$, because the azimuth doesn't supplement the minus operation. We should use the Rotate-By-1-Axis method to get the corret answer, since the combination of fix-axis rotation of rigid body can be seen as one-time fix-axis.

After this work, we take down the Newton-Raphson method as Fig. 4:

\begin{figure}[thpb]
      \centering
      \framebox{
      \parbox{3in}
      {
      $
      Newton\_Raphson(S_{0}, X_{g})\\
      1.\ compute\ X_{0}\ and\ J^{+}; i = 0; times = 0;\\
      2.\ while\ \epsilon < rrtDistance(X_{i}, X_{g})\ and\ times < N\\
      3.\ \{ \\
      4.\qquad S_{i+1} = S_{i} + J^{+}\times minus(X_{g}, X_{i});\\
      5.\qquad i = i + 1;times = times + 1;\\
      6.\qquad compute\ X_{i}\ and\ J^{+};\\
      7.\ \}
      $
	 }
}
      \caption{multi-step extend pseudocode}
      \label{figurelabe4}
\end{figure}

On Fig.4, the 1st and 6th line use (6) and (10) to compute it. Here we use N (we set it to 10 in program) to limit the iteration time, for the fact that Newton-Raphson method would always get the correct answer in less than 10 iteration times with accuracy of micrometer, otherwise it would fail with bias greater than $\epsilon$, i.e., more iteration times have no use cause it can't improve the accuracy.  

\subsection{Comparation with MLG}

At the beginning, we have complement the MLG method before using Newton-Raphson method for inverse-optimization. Here, we introduce MLG method and compare it with Newton-Raphson method, to see some great properties of Newton-Raphson.

MLG method is also a iteration method, using the gradient of current point as the iteration direction, the detail of it can be seen in [3]. We just make comparation between MLG and Newton-Raphson method.

Time, iteration times, accuracy compare figure locating here.

\begin{table*}[h]
\caption{$Comparation\ between\ RRT\ and\ $ Newton-Raphson $ method.\ q_{0} = [0.7854;0.5236;0;0.5236;0;0.5236;0];\ X_{0}=[0.5045;0.5045;0.7223;2.3562;1.5708;-1.5708];\ dist = rrtDistance(X_{0}, X_{g}), all\ their\ units\ are\ meters(m). `\surd'\ means\ successful.\ `\times'\ means\ result\ failed,\ i.e.,\ bias\ (accuracy)\ comes\ out\ more\ than\ 0.1m.$}
\label{table2}
\begin{center}
\begin{tabular}{c|c|c|c|c|c|c}
\hline
No. & task(m) & Method & iteration times & time spent($10^{-3}s$) & accuracy(m) & result \\
\hline
\multirow{4}{*}{1}  &
\multirow{4}{*}{
$
\begin{array}{l}
X_{g} = 
\left[
\begin{array}{c}
0.50; 
0.45;
0.72;
2.35;
1.57;
-1.57
\end{array}
\right] \\ \\
dist = 0.045.
\end{array}
$}
  & N-R & 5 & $6.15$ & $1.28\times 10^{-9}$ & $\surd$ \\
\cline{3-7}
  &    &         & 5 & $5.70$ & $6.50\times10^{-3}$ & $\surd$ \\ \cline{4-7}
   &    & MLG & 10 & $6.52$ & $2.64\times10^{-3}$ & $\surd$ \\ \cline{4-7}
   &    &         & 20 & $11.76$ & $1.25\times10^{-3}$ & $\surd$ \\ 
\hline
\multirow{4}{*}{2} & 
\multirow{4}{*}{
$
\begin{array}{l}
X_{g} = 
\left[
\begin{array}{c}
0.5;
0.48;
0.72;
2.35;
1.55;
-1.55
\end{array}
\right] \\ \\
dist = 0.025.
\end{array}
$
}
& N-R & 4 & 2.38 & $2.34\times10^{-7}$ & $\surd$ \\
\cline{3-7}
 &     &         & 5 & 3.95 & $9.74\times10^{-2}$ & $\surd$\\
\cline{4-7}
 &     &  MLG &10& 6.60 & $9.56\times10^{-2}$ & $\surd$\\
 \cline{4-7}
 &     &         &20& 12.77& $9.39\times10^{-2}$ & $\surd$\\
\hline
\multirow{4}{*}{3}
&
\multirow{4}{*}{
$
\begin{array}{l}
X_{g} = 
\left[
\begin{array}{c}
0.44;
0.44;
0.68;
2.30;
1.57;
-1.57
\end{array}
\right] \\ \\
dist = 0.092.
\end{array}
$
}
& N-R & 7 &3.87 & $5.87\times10^{-8}$ & $\surd$ \\
\cline{3-7}
 &    &        & 5 & 3.94 & $1.65\times10^{-2}$ & $\surd$ \\
\cline{4-7}
 &    & MLG &10& 6.64 & $1.73\times10^{-2}$ & $\surd$ \\
 \cline{4-7}
 &    &         &20& 12.20& $1.78\times10^{-2}$ & $\surd$ \\
 \hline
\multirow{4}{*}{4}
&
\multirow{4}{*}{
$
\begin{array}{l}
X_{g} = 
\left[
\begin{array}{c}
0.45;
0.55;
0.60;
2.00;
1.57;
-1.57
\end{array}
\right] \\ \\
dist = 0.184.
\end{array}
$
}
& N-R & 9 &5.70 & $5.53\times10^{-10}$ & $\surd$ \\
\cline{3-7}
 &    &        & 5 & 4.46 & $1.37\times10^{-1}$ & $\times$ \\
\cline{4-7}
 &    &  MLG &10& 7.31 & $1.22\times10^{-1}$ & $\times$ \\
 \cline{4-7}
 &    &         &20& 11.65& $1.12\times10^{-1}$ & $\times$ \\
 \hline 
\end{tabular}
\end{center}
\end{table*}

We do comparation between these two method using 4 groups of experiments. These tests start with the same initial point $q_0$, and so the same with $X_0$, and go to different end point appointed by $X_{g}$. Note that the iteration times of MLG method can be a input variable which can be assigned before MLG algorithm runs. So we take 5, 10, and 20 iteration times as examples. 

As table 2 shows, in these groups of exprements, we make sense that:

\begin{itemize}

\item  The time spent by Newton-Rapshon method is almost the same with 5-iteration-times MLG method, sometimes even less than it.
\item  Newton-Raphson method uses less than 10 iteration times ending up with bias no more than $10^{-6}m$, but MLG method, no matter using 5, 10, or 20 iteration times, always ending up with deviration error higher than $10^{-3}m$, spending time in the same order of Newton-Raphson method.  
\item Newton-Raphson method adapt to a wider range of `dist' change, i.e., it is suitified to more tasks when doing inverse kinematics. When `dist' becomes bigger, Newton-Raphson works better than MLG method, that can be find in group 4, with Newton-Raphson method successful and MLG failed. Here, we limit the result bias to $0.1m$, i.e., when the accuracy is bigger than this number, we think it failed. 
\item When Newton-Raphson method fail in doing inverse kinematics, MLG method may always can't work well, because they both use the gradient of current point. Minded that whether the result fail or success doesn't depend on `dist' parameter, it is decided by many reasons. Sometimes a small `dist' even like $0.02m$ may also result in fail both for Newton-Raphson method and MLG method.

\end{itemize}

One point which should be reminded is that we implement MLG method according to [3]. There exists some limitaion condition with the end trajectory, e.g., the velocity of end manipulator can't be 0, which is set to greater than 0.05 in our program. So more iteration times may not makes the more accuracy in MLG method. But the conclusion that MLG method always ends up with accuracy of $10^{-3}m\sim10^{-2}m$ when it successes is right, which has been tested by many times of experiments. 

\section{Quintic Polynomial with path smoothing}

There comes another question after doing Newton-Raphson method: knowing $S_{0}$ and $S_{g}$, how could we move the manipulor? The most direct answer might be simply adapt the joint angle to goal angle, however, we can't know the trajectory of the end manipulator in this way, and it might be also not the shortest distance in the thought of end manipulator. Thus, we need to smooth the path from $S_{0}$ crossing a little distance to $S_{g}$. 

As mentioned before, MLG method can do the path smoothing in its iteration, i.e., when finishing compute $S_{g}$, it also finishes planning the path from $S_{0}$ to $S_{g}$, with a designing trajectory of then end manipulator, as for a straight line. But the same thing cannot apply to Newton-Raphson, for its variant iteration times and variant distance within one iteration. So we need to do path planning separately. The quintic polynomial thus has been use in our program, the principle of whihc can be seen in [9]. We use its basic conclusion. Supposed we know $S_{0}$ and $S_{g}$, and their distance ($rrtDistance(S_{0}, S_{g}) =s$, see in (15)) fixed, we need to plan the medium path in 1 second (of course it can be changed by timing a factor). Then in quintic polynomial method, we plan the path as in (17):

$$
\begin{array}{c}
S(t) = a_{5}t^5+a_{4}t^4+a_{3}t^3+a_{2}t^2+a_{1}t+a_{0};\\
with:
\left \{
\begin{array}{ll}
a_{5} = &6(S_{g}-S_{0});\\
a_{4} = &-15(S_{g}-S_{0});\\
a_{3} = &10(S_{g}-S_{0});\\
a_{2} = &0;\\
a_{1} = &0;\\
a_{0} = &S_{0};\\
\end{array}
\right.
\end{array}
\eqno(17)
$$

Using (17), we can get a smooth path. When $t = 0s$, $S(t)$ equals to $S_{0}$, that is the initial point,  and when $t = 1s$, $S(t)$ equals to $S_{g}$, that is the goal point. And we can also compute the speed of path giving by (17), just by doing differential operation. What we can deduce from (17) is that the speed of end manipulator when in initial point or goal point is 0. We could also change the coefficients from $a_{0}$ to $a_{5}$ according to [9] to fit different uses. These method works well on our 7-arm robot manipulator when doing exprements.

\section{RRT-GD to adapt RRT to goal-direction}

When finishing the work above, we can already finishing any work in the work space in theory. But just as the problem we have mentioned in chapter 3, both RRT and its modified method have the great opportunity to explore unuseful space which we don't need in our daily task, i.e., it lacks goal-direction. In order to solve this problem, taking the normal task in our experiment circumstance into account, we turn our sights to the `sample' function in RRT. Simple to find that if we just don't use a whole space sample method, but limit it to a useful space, we can decide the extend direction of RRT tree $T$, that is the kernel principle within our modified RRT method called RRT-GD.

Originally, `sample' method is random in the whole work space, and thus then extend direction is all-around. The sketch map can be seen in Fig. 6. When we use a space containning the goal point $X_{0}$, which can simply be a sphere with $X_{0}$ centering (of course other shape also works, e.g., cuboid), the extending direction can be limit to goal-direction, as Fig.6 shows. In our program, we implement sample method with both sphere mode and cuboid mode, both work well with our daily task. We can see the comparation between RRT and RRT-GD with time property.

\section{CONCLUSIONS}

In this paer, we introduce a new method in obstacle-avoiding path planning, with modified RRT method doing obstacle-avoiding, Newton-Raphson doing inverse kinematics, and quintic polynomial doing path smoothing. After that, we find the less goal-direction with RRT and its modified algorithm, so we implement RRT-GD to solve this problem. With RRT-GD, we can accomplish daily works faster and more efficient.

\addtolength{\textheight}{-12cm}   % This command serves to balance the column lengths
                                  % on the last page of the document manually. It shortens
                                  % the textheight of the last page by a suitable amount.
                                  % This command does not take effect until the next page
                                  % so it should come on the page before the last. Make
                                  % sure that you do not shorten the textheight too much.

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%



%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%



%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%



%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%



\begin{thebibliography}{99}

\bibitem{c1} A Methodology for Intelligent Path Planning, Suman Chakravorty, John L. Junkins. Department of Aerospace Engineering, Texas A\&M University Young, College Station.
\bibitem{c2} Kinect-based Service Robot for Desktop Cleaning, Zheng Han, Meng Gao, ShiJiaZhuang Tiedao University.
\bibitem{c3} Planning Method Considering the kinetic characteristics of the end effector of a redundant manipulator, Wenbing Huang, Fuchun Sun, Huaping Liu, Qinghua Daxue Xuebao/journal of Tsinghua University, 2014,54(12):1544-1548.
\bibitem{c4} Incremental kinesthetic teaching of motion primitives using the motion refinement tube, Dongheui Lee, Chritian Ott, Autonomous Robots, 2011, 31(2-3):115-131.
\bibitem{c5} New Heuristic Algorithms for Efficient Hierarchical Path Planning,  David Zhu and Jean-Claude Latombe, IEEE Transactions on Robotics \& Automation, 1991.7(1):9-20.
\bibitem{c6} A Subdivision Algorithm in Configuration for Findpath with Rotation, Rodney A. Brooks, Tomas Lozano-Perez, Systems Man \& Cybemetics IEEE Transactions on, 1985, SMC-15(2):244-233.
\bibitem{c7} Motion Planning and Skill Transfer of Anthropomorphic Arms Based on Movement Primitives，Xilun Ding, Cheng Fang, International Conference on Mechatronics \& Automation, 2012:303-310.
\bibitem{c8} Algorithm Based on Analytical Method and Genetic Algorithm for Inverse Kinematics of Redundant Manipulator, Yun Dong, Tao Yang, Wen Li, Computer Simulation, 2012.
\bibitem{c9} Trajectory Planning for a Robotic Ping-pong Player, Guowei Zhang, Bin Li, Huaibing Zhen, Haili Gong, Cong Wang, Chinese Journal of Scientific Instrument, Vol.32 No.6, Jun 2011.
\bibitem{c10} Virtual Reality in the Loop – Providing an Interface for an Intelligent Rule Learning and Planning System, Jurgen Rossmann, Christian Schlette, Nils Wantia, IEEE International Conference on Robotics \& Automation, 2013.
\bibitem{c11} Research on Kinematics and Obstacle Avoidance Path Planning for Redundant Manipulator, Yin Bin, Shi Shicai, Classified Index:TP242.2, U.D.C:681.5.






\end{thebibliography}




\end{document}
